#!/usr/bin/env node

/**
 * Script de validaci√≥n de configuraci√≥n Docker para producci√≥n
 * Verifica que todos los servicios est√©n configurados correctamente
 */

const fs = require('fs');
const path = require('path');

// Servicios que deben estar configurados
const requiredServices = [
  'user-service',
  'student-service',
  'analytics-service',
  'course-service',
  'resource-service',
  'communication-service',
  'gateway'
];

// Variables de entorno cr√≠ticas para Docker
const requiredEnvVars = [
  'DATABASE_URL',
  'NODE_ENV',
  'PORT',
  'SESSION_SECRET',
  'JWT_SECRET',
  'CORS_ORIGIN',
  'REDIS_URL',
  'GOOGLE_CLIENT_ID',
  'GOOGLE_CLIENT_SECRET'
];

// Variables de entorno para microservicios
const microserviceEnvVars = [
  'DATABASE_URL',
  'NODE_ENV',
  'PORT',
  'JWT_SECRET',
  'REDIS_URL',
  'LOG_LEVEL'
];

function validateDockerfile(servicePath, serviceName) {
  console.log(`üîç Validando Dockerfile para ${serviceName}...`);
  
  const dockerfilePath = path.join(servicePath, 'Dockerfile');
  
  if (!fs.existsSync(dockerfilePath)) {
    console.error(`‚ùå Dockerfile no encontrado para ${serviceName}`);
    return false;
  }
  
  const content = fs.readFileSync(dockerfilePath, 'utf8');
  
  // Verificar elementos cr√≠ticos
  const checks = [
    { name: 'FROM node', pattern: /FROM node/, required: true },
    { name: 'WORKDIR', pattern: /WORKDIR/, required: true },
    { name: 'EXPOSE', pattern: /EXPOSE/, required: true },
    { name: 'HEALTHCHECK', pattern: /HEALTHCHECK/, required: true },
    { name: 'Usuario no-root', pattern: /adduser|USER/, required: true },
    { name: 'CMD', pattern: /CMD/, required: true }
  ];
  
  let allPassed = true;
  checks.forEach(check => {
    if (check.required && !check.pattern.test(content)) {
      console.error(`  ‚ùå ${check.name} no encontrado`);
      allPassed = false;
    } else if (check.pattern.test(content)) {
      console.log(`  ‚úÖ ${check.name} encontrado`);
    }
  });
  
  return allPassed;
}

function validateDockerCompose() {
  console.log('\nüîç Validando docker-compose.prod.yml...');
  
  const composePath = path.join(process.cwd(), 'docker-compose.prod.yml');
  
  if (!fs.existsSync(composePath)) {
    console.error('‚ùå docker-compose.prod.yml no encontrado');
    return false;
  }
  
  const content = fs.readFileSync(composePath, 'utf8');
  
  // Verificar elementos cr√≠ticos
  const checks = [
    { name: 'Version', pattern: /version:\s*['"]3\.8['"]/, required: true },
    { name: 'PostgreSQL', pattern: /postgres:/, required: true },
    { name: 'Redis', pattern: /redis:/, required: true },
    { name: 'Networks', pattern: /networks:/, required: true },
    { name: 'Volumes', pattern: /volumes:/, required: true },
    { name: 'Health checks', pattern: /healthcheck:/, required: true },
    { name: 'Environment variables', pattern: /environment:/, required: true }
  ];
  
  let allPassed = true;
  checks.forEach(check => {
    if (check.required && !check.pattern.test(content)) {
      console.error(`  ‚ùå ${check.name} no encontrado`);
      allPassed = false;
    } else if (check.pattern.test(content)) {
      console.log(`  ‚úÖ ${check.name} encontrado`);
    }
  });
  
  return allPassed;
}

function validateMainDockerfile() {
  console.log('\nüîç Validando Dockerfile principal...');
  
  const dockerfilePath = path.join(process.cwd(), 'Dockerfile');
  
  if (!fs.existsSync(dockerfilePath)) {
    console.error('‚ùå Dockerfile principal no encontrado');
    return false;
  }
  
  const content = fs.readFileSync(dockerfilePath, 'utf8');
  
  // Verificar elementos cr√≠ticos
  const checks = [
    { name: 'Multi-stage build', pattern: /FROM.*AS.*base/, required: true },
    { name: 'Production stage', pattern: /FROM.*AS.*production/, required: true },
    { name: 'Non-root user', pattern: /adduser|USER/, required: true },
    { name: 'Health check', pattern: /HEALTHCHECK/, required: true },
    { name: 'Environment variables', pattern: /ENV NODE_ENV=production/, required: true },
    { name: 'Port exposure', pattern: /EXPOSE 3000/, required: true },
    { name: 'Build process', pattern: /npm run build/, required: true }
  ];
  
  let allPassed = true;
  checks.forEach(check => {
    if (check.required && !check.pattern.test(content)) {
      console.error(`  ‚ùå ${check.name} no encontrado`);
      allPassed = false;
    } else if (check.pattern.test(content)) {
      console.log(`  ‚úÖ ${check.name} encontrado`);
    }
  });
  
  return allPassed;
}

function validateRenderConfig() {
  console.log('\nüîç Validando configuraci√≥n de Render...');
  
  const renderPath = path.join(process.cwd(), 'render.yaml');
  
  if (!fs.existsSync(renderPath)) {
    console.error('‚ùå render.yaml no encontrado');
    return false;
  }
  
  const content = fs.readFileSync(renderPath, 'utf8');
  
  // Verificar elementos cr√≠ticos
  const checks = [
    { name: 'Service definition', pattern: /type:\s*web/, required: true },
    { name: 'Build command', pattern: /buildCommand:/, required: true },
    { name: 'Start command', pattern: /startCommand:/, required: true },
    { name: 'Environment variables', pattern: /envVars:/, required: true },
    { name: 'Health check', pattern: /healthCheckPath:/, required: true },
    { name: 'Database configuration', pattern: /databases:/, required: true }
  ];
  
  let allPassed = true;
  checks.forEach(check => {
    if (check.required && !check.pattern.test(content)) {
      console.error(`  ‚ùå ${check.name} no encontrado`);
      allPassed = false;
    } else if (check.pattern.test(content)) {
      console.log(`  ‚úÖ ${check.name} encontrado`);
    }
  });
  
  return allPassed;
}

function validateEnvironmentVariables() {
  console.log('\nüîç Validando variables de entorno...');
  
  // Verificar production.env
  const productionEnvPath = path.join(process.cwd(), 'production.env');
  
  if (!fs.existsSync(productionEnvPath)) {
    console.error('‚ùå production.env no encontrado');
    return false;
  }
  
  const content = fs.readFileSync(productionEnvPath, 'utf8');
  
  let allPassed = true;
  requiredEnvVars.forEach(varName => {
    if (!content.includes(varName)) {
      console.error(`  ‚ùå Variable ${varName} no encontrada en production.env`);
      allPassed = false;
    } else {
      console.log(`  ‚úÖ Variable ${varName} encontrada`);
    }
  });
  
  return allPassed;
}

function validateMicroservices() {
  console.log('\nüîç Validando microservicios...');
  
  const microservicesPath = path.join(process.cwd(), 'microservices');
  
  if (!fs.existsSync(microservicesPath)) {
    console.error('‚ùå Directorio microservices no encontrado');
    return false;
  }
  
  let allPassed = true;
  requiredServices.forEach(serviceName => {
    const servicePath = path.join(microservicesPath, serviceName);
    
    if (!fs.existsSync(servicePath)) {
      console.error(`‚ùå Microservicio ${serviceName} no encontrado`);
      allPassed = false;
      return;
    }
    
    console.log(`\nüìÅ Validando ${serviceName}...`);
    
    // Verificar Dockerfile
    const dockerfileValid = validateDockerfile(servicePath, serviceName);
    if (!dockerfileValid) {
      allPassed = false;
    }
    
    // Verificar package.json
    const packagePath = path.join(servicePath, 'package.json');
    if (!fs.existsSync(packagePath)) {
      console.error(`  ‚ùå package.json no encontrado para ${serviceName}`);
      allPassed = false;
    } else {
      console.log(`  ‚úÖ package.json encontrado`);
    }
    
    // Verificar scripts de build
    if (fs.existsSync(packagePath)) {
      const packageContent = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
      if (!packageContent.scripts || !packageContent.scripts.build) {
        console.error(`  ‚ùå Script de build no encontrado para ${serviceName}`);
        allPassed = false;
      } else {
        console.log(`  ‚úÖ Script de build encontrado`);
      }
    }
  });
  
  return allPassed;
}

function validateSecurity() {
  console.log('\nüîç Validando configuraci√≥n de seguridad...');
  
  let allPassed = true;
  
  // Verificar .dockerignore
  const dockerignorePath = path.join(process.cwd(), '.dockerignore');
  if (!fs.existsSync(dockerignorePath)) {
    console.error('‚ùå .dockerignore no encontrado');
    allPassed = false;
  } else {
    const content = fs.readFileSync(dockerignorePath, 'utf8');
    if (!content.includes('.env') || !content.includes('node_modules')) {
      console.error('‚ùå .dockerignore no excluye archivos sensibles');
      allPassed = false;
    } else {
      console.log('‚úÖ .dockerignore configurado correctamente');
    }
  }
  
  // Verificar que no hay claves reales en archivos de configuraci√≥n
  const configFiles = ['production.env', 'render.yaml'];
  configFiles.forEach(file => {
    const filePath = path.join(process.cwd(), file);
    if (fs.existsSync(filePath)) {
      const content = fs.readFileSync(filePath, 'utf8');
      const realKeyPatterns = [
        /sk-[a-zA-Z0-9]{48}/,
        /AIza[a-zA-Z0-9_-]{35}/,
        /ghp_[a-zA-Z0-9]{36}/
      ];
      
      realKeyPatterns.forEach(pattern => {
        if (pattern.test(content)) {
          console.error(`‚ùå Se encontraron claves reales en ${file}`);
          allPassed = false;
        }
      });
    }
  });
  
  if (allPassed) {
    console.log('‚úÖ Configuraci√≥n de seguridad v√°lida');
  }
  
  return allPassed;
}

function generateDockerProductionReport() {
  console.log('\nüìã Generando reporte de configuraci√≥n Docker para producci√≥n...');
  
  const report = {
    timestamp: new Date().toISOString(),
    mainDockerfile: validateMainDockerfile(),
    dockerCompose: validateDockerCompose(),
    renderConfig: validateRenderConfig(),
    environmentVariables: validateEnvironmentVariables(),
    microservices: validateMicroservices(),
    security: validateSecurity()
  };
  
  const reportPath = path.join(process.cwd(), 'docker-production-report.json');
  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
  
  console.log(`‚úÖ Reporte guardado en: ${reportPath}`);
  
  return report;
}

function showRecommendations() {
  console.log('\nüí° Recomendaciones para producci√≥n:');
  console.log('1. ‚úÖ Usar multi-stage builds para optimizar el tama√±o de imagen');
  console.log('2. ‚úÖ Implementar usuarios no-root en todos los contenedores');
  console.log('3. ‚úÖ Configurar health checks para todos los servicios');
  console.log('4. ‚úÖ Usar variables de entorno para configuraci√≥n');
  console.log('5. ‚úÖ Implementar logging centralizado');
  console.log('6. ‚úÖ Configurar backups autom√°ticos de base de datos');
  console.log('7. ‚úÖ Implementar monitoreo y alertas');
  console.log('8. ‚úÖ Usar secrets management para claves sensibles');
  console.log('9. ‚úÖ Configurar rate limiting y seguridad');
  console.log('10. ‚úÖ Implementar CI/CD para despliegues autom√°ticos');
}

function main() {
  console.log('üöÄ Validando configuraci√≥n Docker para producci√≥n...\n');
  
  const report = generateDockerProductionReport();
  
  console.log('\nüìä Resumen de validaci√≥n:');
  console.log(`‚úÖ Dockerfile principal: ${report.mainDockerfile ? 'V√ÅLIDO' : '‚ùå PROBLEMAS'}`);
  console.log(`‚úÖ Docker Compose: ${report.dockerCompose ? 'V√ÅLIDO' : '‚ùå PROBLEMAS'}`);
  console.log(`‚úÖ Configuraci√≥n Render: ${report.renderConfig ? 'V√ÅLIDO' : '‚ùå PROBLEMAS'}`);
  console.log(`‚úÖ Variables de entorno: ${report.environmentVariables ? 'V√ÅLIDO' : '‚ùå PROBLEMAS'}`);
  console.log(`‚úÖ Microservicios: ${report.microservices ? 'V√ÅLIDO' : '‚ùå PROBLEMAS'}`);
  console.log(`‚úÖ Seguridad: ${report.security ? 'V√ÅLIDO' : '‚ùå PROBLEMAS'}`);
  
  const allValid = Object.values(report).every(value => value === true);
  
  if (allValid) {
    console.log('\nüéâ ¬°Toda la configuraci√≥n Docker est√° lista para producci√≥n!');
  } else {
    console.log('\n‚ö†Ô∏è  Se encontraron problemas en la configuraci√≥n Docker');
    console.log('üí° Revisa los errores anteriores y corrige los problemas');
  }
  
  showRecommendations();
}

if (require.main === module) {
  main();
}

module.exports = {
  validateDockerfile,
  validateDockerCompose,
  validateMainDockerfile,
  validateRenderConfig,
  validateEnvironmentVariables,
  validateMicroservices,
  validateSecurity,
  generateDockerProductionReport
}; 