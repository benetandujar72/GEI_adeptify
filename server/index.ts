import express from 'express';
import session from 'express-session';
import passport from 'passport';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import { createServer } from 'http';
import { WebSocketServer } from 'ws';
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import { config } from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';

// Configuraci√≥n de variables de entorno
config();

// Configuraci√≥n de rutas de archivos
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Importaciones de servicios
import { initializeDatabase } from './database/init.js';
import { setupPassport } from './auth/passport.js';
import { setupRoutes } from './routes/index.js';
import { setupWebSocket } from './websocket/index.js';
import { NotificationService } from './websocket/notification-service.js';
import { errorHandler } from './middleware/error-handler.js';
import { logger } from './utils/logger.js';
import { auditAuth } from './middleware/audit.js';
import { cacheService } from './services/cache-service.js';
import { databaseOptimizer } from './services/database-optimizer.js';
import { aiChatbotService } from './services/ai-chatbot-service.js';
import { aiAnalyticsService } from './services/ai-analytics-service.js';
import { aiReportGeneratorService } from './services/ai-report-generator.js';
import { calendarService } from './services/calendar-service.js';

// Configuraci√≥n de la aplicaci√≥n
const app = express();
const server = createServer(app);
const port = process.env.PORT || 3001;

// Configuraci√≥n de base de datos
const databaseUrl = process.env.DATABASE_URL || 'postgresql://gei_user:gei_password@localhost:5432/gei_unified';

// Configuraci√≥n de conexi√≥n con SSL para Render
const sql = postgres(databaseUrl, {
  max: 5, // M√°ximo 5 conexiones en el pool
  idle_timeout: 20, // Cerrar conexiones inactivas despu√©s de 20 segundos
  connect_timeout: 10, // Timeout de conexi√≥n de 10 segundos
  ssl: process.env.NODE_ENV === 'production' ? {
    rejectUnauthorized: false // Para Render.com
  } : false,
  connection: {
    application_name: 'gei-unified-platform'
  }
});
export const db = drizzle(sql);

// Middleware de seguridad
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      imgSrc: ["'self'", "data:", "https:"],
      scriptSrc: ["'self'", "'unsafe-inline'", "'sha256-adZL5tq2getU14Zvm3HPDk7Uivy3/+4vhfw8OLrqKhY='"],
      scriptSrcAttr: ["'unsafe-inline'"],
      connectSrc: process.env.NODE_ENV === 'production' 
        ? ["'self'", "ws:", "wss:", "https://gei.adeptify.es", "https://gei-adeptify.onrender.com"]
        : ["'self'", "ws:", "wss:", "http://localhost:3001", "http://localhost:3000"],
    },
  },
}));

// Middleware de compresi√≥n
app.use(compression());

// Configuraci√≥n de CORS
app.use(cors({
  origin: process.env.NODE_ENV === 'production' 
    ? process.env.CORS_ORIGIN || 'https://gei.adeptify.es'
    : ['http://localhost:3001', 'http://localhost:3000'],
  credentials: true,
}));

// Middleware de logging para todas las peticiones
app.use((req, res, next) => {
  const startTime = Date.now();
  
  logger.info(`üåê ${req.method} ${req.path} - Iniciando petici√≥n`);
  logger.info(`üìã User-Agent: ${req.headers['user-agent']}`);
  logger.info(`üåç IP: ${req.ip || req.connection.remoteAddress}`);
  
  // Log de respuesta
  res.on('finish', () => {
    const duration = Date.now() - startTime;
    logger.info(`‚úÖ ${req.method} ${req.path} - ${res.statusCode} (${duration}ms)`);
  });
  
  next();
});

// Middleware de parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Middleware de cookies
// app.use(cookieParser()); // Eliminado

// Configuraci√≥n de sesiones
import connectPg from 'connect-pg-simple';

const PostgresStore = connectPg(session);

app.use(session({
  secret: process.env.SESSION_SECRET || 'dev-secret-key-change-in-production',
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000, // 24 horas
    sameSite: process.env.NODE_ENV === 'production' ? 'strict' : 'lax',
  },
  // TEMPORAL: Usar MemoryStore para evitar problemas SSL con PostgreSQL
  // store: process.env.NODE_ENV === 'production' 
  //   ? new PostgresStore({
  //       conString: process.env.DATABASE_URL,
  //       createTableIfMissing: true,
  //       ttl: 24 * 60 * 60, // 24 horas en segundos
  //       tableName: 'sessions'
  //     })
  //   : undefined, // Usar MemoryStore solo en desarrollo
}));

// Configuraci√≥n de Passport
app.use(passport.initialize());
app.use(passport.session());
setupPassport(passport);

// Middleware de auditor√≠a para autenticaci√≥n
app.use(auditAuth());

// Endpoint temporal para manifest.json
app.get('/manifest.json', (req, res) => {
  logger.info('üîç ===== PETICI√ìN MANIFEST.JSON RECIBIDA (ENDPOINT TEMPORAL) =====');
  
  const manifestContent = {
    "name": "GEI Unified Platform",
    "short_name": "GEI Platform",
    "description": "Plataforma Unificada de Gesti√≥n Educativa Integral",
    "start_url": "/",
    "display": "standalone",
    "background_color": "#ffffff",
    "theme_color": "#3b82f6",
    "icons": [
      {
        "src": "/logo.svg",
        "sizes": "any",
        "type": "image/svg+xml",
        "purpose": "any maskable"
      }
    ]
  };
  
  logger.info('‚úÖ Enviando manifest.json desde endpoint temporal');
  res.setHeader('Content-Type', 'application/json');
  res.json(manifestContent);
});

// Endpoint temporal para logo.svg
app.get('/logo.svg', (req, res) => {
  logger.info('üîç ===== PETICI√ìN LOGO.SVG RECIBIDA (ENDPOINT TEMPORAL) =====');
  
  const logoSvg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
  <defs>
    <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#3b82f6;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#1d4ed8;stop-opacity:1" />
    </linearGradient>
  </defs>
  
  <!-- Fondo circular -->
  <circle cx="50" cy="50" r="45" fill="url(#grad1)" stroke="#1e40af" stroke-width="2"/>
  
  <!-- Letra G estilizada -->
  <path d="M30 25 Q30 15 40 15 L60 15 Q70 15 70 25 L70 35 Q70 45 60 45 L45 45 L45 55 L60 55 Q70 55 70 65 L70 75 Q70 85 60 85 L40 85 Q30 85 30 75 L30 65 Q30 55 40 55 L55 55 L55 45 L40 45 Q30 45 30 35 Z" 
        fill="white" stroke="white" stroke-width="1"/>
  
  <!-- Elementos decorativos -->
  <circle cx="25" cy="25" r="3" fill="#fbbf24" opacity="0.8"/>
  <circle cx="75" cy="75" r="3" fill="#fbbf24" opacity="0.8"/>
  <circle cx="75" cy="25" r="2" fill="#fbbf24" opacity="0.6"/>
  <circle cx="25" cy="75" r="2" fill="#fbbf24" opacity="0.6"/>
</svg>`;
  
  logger.info('‚úÖ Enviando logo.svg desde endpoint temporal');
  res.setHeader('Content-Type', 'image/svg+xml');
  res.send(logoSvg);
});

// Servir archivos est√°ticos del cliente
if (process.env.NODE_ENV === 'production') {
  logger.info('üìÅ ===== INICIO CONFIGURACI√ìN ARCHIVOS EST√ÅTICOS =====');
  logger.info('üîÑ REDEPLOY FORZADO - Verificando archivos manifest.json y logo.svg');
  logger.info(`üìÇ __dirname: ${__dirname}`);
  logger.info(`üìÇ process.cwd(): ${process.cwd()}`);
  
  // Intentar m√∫ltiples rutas posibles para los archivos est√°ticos
  const possiblePaths = [
    path.join(process.cwd(), 'client/dist'),  // Docker production path
    path.join(__dirname, '../client/dist'),
    path.join(__dirname, '../../client/dist'),
    path.join(__dirname, '../dist/client'),
    path.join(__dirname, './client/dist'),
    path.join(process.cwd(), 'dist/client'),
    path.join(process.cwd(), 'dist')
  ];
  
  logger.info('üîç ===== PROBANDO RUTAS POSIBLES =====');
  let staticPath = null;
  for (const testPath of possiblePaths) {
    logger.info(`üîç Probando ruta: ${testPath}`);
    const exists = fs.existsSync(testPath);
    logger.info(`   ${exists ? '‚úÖ EXISTE' : '‚ùå NO EXISTE'}: ${testPath}`);
    
    if (exists) {
      staticPath = testPath;
      logger.info(`üéØ DIRECTORIO ENCONTRADO: ${staticPath}`);
      break;
    }
  }
  
  if (!staticPath) {
    logger.error('‚ùå ===== CR√çTICO: NO SE ENCONTR√ì NING√öN DIRECTORIO =====');
    possiblePaths.forEach(p => logger.error(`   üîç Buscado en: ${p}`));
    logger.error('‚ùå ===== FIN CONFIGURACI√ìN ARCHIVOS EST√ÅTICOS =====');
  } else {
    logger.info('üìã ===== LISTANDO CONTENIDO DEL DIRECTORIO =====');
    // Listar archivos en el directorio
    try {
      const files = fs.readdirSync(staticPath);
      logger.info(`üìã Total archivos encontrados: ${files.length}`);
      logger.info(`üìÇ Directorio: ${staticPath}`);
      
      // Buscar archivos espec√≠ficos
      const manifestExists = files.includes('manifest.json');
      const logoExists = files.includes('logo.svg');
      const indexExists = files.includes('index.html');
      
      logger.info(`üìÑ manifest.json: ${manifestExists ? '‚úÖ ENCONTRADO' : '‚ùå NO ENCONTRADO'}`);
      logger.info(`üìÑ logo.svg: ${logoExists ? '‚úÖ ENCONTRADO' : '‚ùå NO ENCONTRADO'}`);
      logger.info(`üìÑ index.html: ${indexExists ? '‚úÖ ENCONTRADO' : '‚ùå NO ENCONTRADO'}`);
      
      // Listar todos los archivos
      files.forEach((file, index) => {
        logger.info(`   ${index + 1}. ${file}`);
      });
      
    } catch (error) {
      logger.error('‚ùå Error leyendo directorio de archivos est√°ticos:', error);
    }
    
    // Endpoints espec√≠ficos para archivos cr√≠ticos (ANTES de express.static)
    app.get('/manifest.json', (req, res) => {
      logger.info('üîç ===== PETICI√ìN MANIFEST.JSON RECIBIDA =====');
      logger.info(`üìÇ staticPath: ${staticPath}`);
      const manifestPath = path.join(staticPath, 'manifest.json');
      logger.info(`üìÇ Ruta completa: ${manifestPath}`);
      
      const fileExists = fs.existsSync(manifestPath);
      logger.info(`üìÑ Archivo existe: ${fileExists ? '‚úÖ S√ç' : '‚ùå NO'}`);
      
      if (fileExists) {
        logger.info('‚úÖ manifest.json encontrado, enviando archivo');
        res.setHeader('Content-Type', 'application/json');
        res.sendFile(manifestPath);
      } else {
        logger.error('‚ùå ===== MANIFEST.JSON NO ENCONTRADO =====');
        logger.error(`üìÇ Buscado en: ${manifestPath}`);
        logger.error(`üìÇ staticPath: ${staticPath}`);
        logger.error(`üìÇ __dirname: ${__dirname}`);
        logger.error(`üìÇ process.cwd(): ${process.cwd()}`);
        
        // Intentar listar el directorio para debug
        try {
          const files = fs.readdirSync(staticPath);
          logger.error(`üìã Archivos en el directorio: ${files.join(', ')}`);
        } catch (listError) {
          logger.error('‚ùå Error listando directorio:', listError);
        }
        
        res.status(404).json({ 
          error: 'manifest.json not found',
          searchedPath: manifestPath,
          staticPath: staticPath,
          currentDir: __dirname,
          processCwd: process.cwd()
        });
      }
    });
    
    app.get('/logo.svg', (req, res) => {
      logger.info('üîç ===== PETICI√ìN LOGO.SVG RECIBIDA =====');
      const logoPath = path.join(staticPath, 'logo.svg');
      logger.info(`üìÇ Ruta completa: ${logoPath}`);
      
      const fileExists = fs.existsSync(logoPath);
      logger.info(`üìÑ Archivo existe: ${fileExists ? '‚úÖ S√ç' : '‚ùå NO'}`);
      
      if (fileExists) {
        logger.info('‚úÖ logo.svg encontrado, enviando archivo');
        res.setHeader('Content-Type', 'image/svg+xml');
        res.sendFile(logoPath);
      } else {
        logger.error('‚ùå ===== LOGO.SVG NO ENCONTRADO =====');
        logger.error(`üìÇ Buscado en: ${logoPath}`);
        res.status(404).json({ 
          error: 'logo.svg not found',
          searchedPath: logoPath,
          staticPath: staticPath
        });
      }
    });
    
    // Middleware espec√≠fico para archivos de assets con logging
    app.use('/assets', (req, res, next) => {
      logger.info(`üîç ===== PETICI√ìN ASSET RECIBIDA =====`);
      logger.info(`üìÇ Ruta solicitada: ${req.url}`);
      logger.info(`üìÇ staticPath: ${staticPath}`);
      logger.info(`üìÇ Ruta completa: ${path.join(staticPath, 'assets', req.url)}`);
      
      const assetPath = path.join(staticPath, 'assets', req.url);
      if (fs.existsSync(assetPath)) {
        logger.info(`‚úÖ Asset encontrado: ${req.url}`);
        next();
      } else {
        logger.error(`‚ùå Asset no encontrado: ${req.url}`);
        logger.error(`üìÇ Buscado en: ${assetPath}`);
        
        // Listar archivos disponibles en assets para debug
        const assetsDir = path.join(staticPath, 'assets');
        if (fs.existsSync(assetsDir)) {
          try {
            const files = fs.readdirSync(assetsDir);
            logger.error(`üìã Archivos disponibles en assets: ${files.join(', ')}`);
          } catch (error) {
            logger.error('‚ùå Error listando archivos de assets:', error);
          }
        } else {
          logger.error(`‚ùå Directorio assets no existe: ${assetsDir}`);
        }
        
        next();
      }
    }, express.static(path.join(staticPath, 'assets')));
    
    // Middleware general para archivos est√°ticos
    app.use(express.static(staticPath));
    
    // Fallback para SPA - servir index.html para rutas no encontradas
    app.get('*', (req, res) => {
      // Solo servir index.html para rutas que no sean API
      if (!req.path.startsWith('/api/')) {
        logger.info(`üîÑ ===== FALLBACK SPA =====`);
        logger.info(`üìÇ Ruta solicitada: ${req.path}`);
        logger.info(`üìÇ Sirviendo index.html`);
        
        const indexPath = path.join(staticPath, 'index.html');
        if (fs.existsSync(indexPath)) {
          res.sendFile(indexPath);
        } else {
          logger.error(`‚ùå index.html no encontrado en: ${indexPath}`);
          res.status(404).json({ 
            error: 'index.html not found',
            path: req.path,
            searchedPath: indexPath
          });
        }
      } else {
        res.status(404).json({ error: 'API endpoint not found', path: req.path });
      }
    });
    
    logger.info('‚úÖ ===== MIDDLEWARE DE ARCHIVOS EST√ÅTICOS CONFIGURADO =====');
    logger.info(`üìÇ Ruta configurada: ${staticPath}`);
    logger.info(`üìÇ Ruta de assets: ${path.join(staticPath, 'assets')}`);
    
    // Verificar que los archivos de assets existen
    const assetsPath = path.join(staticPath, 'assets');
    if (fs.existsSync(assetsPath)) {
      try {
        const assetFiles = fs.readdirSync(assetsPath);
        logger.info(`üìã Archivos en assets: ${assetFiles.join(', ')}`);
      } catch (error) {
        logger.error('‚ùå Error leyendo directorio assets:', error);
      }
    } else {
      logger.error(`‚ùå Directorio assets no encontrado: ${assetsPath}`);
    }
  }
}

// Configuraci√≥n de rutas
app.use('/api', setupRoutes());

// Health check endpoint para Render
app.get('/health', (req, res) => {
  res.status(200).json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV,
    version: process.env.npm_package_version || '1.0.0'
  });
});

// Health check endpoint para API
app.get('/api/health', (req, res) => {
  res.status(200).json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV,
    version: process.env.npm_package_version || '1.0.0',
    services: {
      database: 'connected',
      cache: 'connected',
      notifications: 'active'
    }
  });
});

// Ruta ra√≠z
app.get('/', (req, res) => {
  res.json({
    message: 'GEI Unified Platform API',
    version: process.env.npm_package_version || '1.0.0',
    environment: process.env.NODE_ENV,
    status: 'running'
  });
});

// Endpoint de debug espec√≠fico para manifest.json
app.get('/api/debug-manifest', (req, res) => {
  logger.info('üîç ===== ENDPOINT DEBUG MANIFEST SOLICITADO =====');
  
  const debugInfo: any = {
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV,
    currentDir: __dirname,
    processCwd: process.cwd(),
    possiblePaths: [
      path.join(__dirname, '../client/dist'),
      path.join(__dirname, '../../client/dist'),
      path.join(__dirname, '../dist/client'),
      path.join(__dirname, './client/dist'),
      path.join(process.cwd(), 'client/dist'),
      path.join(process.cwd(), 'dist/client'),
      path.join(process.cwd(), 'dist')
    ]
  };
  
  // Probar cada ruta
  debugInfo.pathTests = [];
  for (const testPath of debugInfo.possiblePaths) {
    const exists = fs.existsSync(testPath);
    debugInfo.pathTests.push({
      path: testPath,
      exists: exists,
      files: exists ? fs.readdirSync(testPath) : null,
      manifestExists: exists ? fs.existsSync(path.join(testPath, 'manifest.json')) : false,
      logoExists: exists ? fs.existsSync(path.join(testPath, 'logo.svg')) : false,
      indexExists: exists ? fs.existsSync(path.join(testPath, 'index.html')) : false
    });
  }
  
  logger.info('üìä Informaci√≥n de debug manifest:', debugInfo);
  res.json(debugInfo);
});

// Endpoint de diagn√≥stico detallado
app.get('/api/debug', (req, res) => {
  try {
    logger.info('üîç Endpoint de diagn√≥stico solicitado');
    
    const staticPath = path.join(__dirname, '../client/dist');
    const indexPath = path.join(staticPath, 'index.html');
    
    const debugInfo: any = {
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV,
      staticPath: staticPath,
      indexPath: indexPath,
      staticPathExists: fs.existsSync(staticPath),
      indexHtmlExists: fs.existsSync(indexPath),
      currentDir: __dirname,
      processCwd: process.cwd(),
      env: {
        NODE_ENV: process.env.NODE_ENV,
        PORT: process.env.PORT,
        CORS_ORIGIN: process.env.CORS_ORIGIN
      }
    };
    
    // Listar archivos si el directorio existe
    if (fs.existsSync(staticPath)) {
      try {
        const files = fs.readdirSync(staticPath);
        debugInfo.files = files;
        debugInfo.fileCount = files.length;
      } catch (error) {
        debugInfo.readError = error instanceof Error ? error.message : 'Unknown error';
      }
    }
    
    logger.info('üìä Informaci√≥n de diagn√≥stico:', debugInfo);
    res.json(debugInfo);
    
  } catch (error) {
    logger.error('‚ùå Error en endpoint de diagn√≥stico:', error);
    res.status(500).json({
      error: error instanceof Error ? error.message : 'Unknown error',
      timestamp: new Date().toISOString()
    });
  }
});

// Configuraci√≥n de WebSocket
const wss = new WebSocketServer({ server });
setupWebSocket(wss);

// Manejo de rutas del cliente (SPA) - SOLO para rutas que no sean API ni archivos est√°ticos
if (process.env.NODE_ENV === 'production') {
  logger.info('üåê Configurando rutas SPA para producci√≥n...');
  
  app.get('*', (req, res, next) => {
    logger.info(`ÔøΩÔøΩ Petici√≥n recibida: ${req.method} ${req.path}`);
    logger.info(`üìã Headers: ${JSON.stringify(req.headers, null, 2)}`);
    
    // No interceptar rutas de API
    if (req.path.startsWith('/api/')) {
      logger.info(`‚úÖ Ruta API detectada, pasando al siguiente middleware: ${req.path}`);
      return next();
    }
    
    // No interceptar archivos est√°ticos
    if (req.path.includes('.') && !req.path.includes('..')) {
      logger.info(`‚úÖ Archivo est√°tico detectado, pasando al siguiente middleware: ${req.path}`);
      return next();
    }
    
    // Para todas las dem√°s rutas, servir index.html (SPA)
    const indexPath = path.join(__dirname, '../client/dist/index.html');
    logger.info(`üåê Sirviendo index.html para ruta SPA: ${req.path}`);
    logger.info(`üìÇ Ruta del archivo: ${indexPath}`);
    
    // Verificar si el archivo existe
    if (fs.existsSync(indexPath)) {
      logger.info('‚úÖ index.html encontrado, enviando archivo');
      res.sendFile(indexPath);
    } else {
      logger.error('‚ùå index.html NO encontrado');
      logger.error(`üîç Buscando en: ${indexPath}`);
      res.status(404).send('index.html no encontrado');
    }
  });
  
  logger.info('‚úÖ Rutas SPA configuradas');
}

// Middleware de manejo de errores
app.use(errorHandler);

// Inicializar servicio de notificaciones
let notificationService: NotificationService;

// Funci√≥n de inicializaci√≥n
async function initializeApp() {
  try {
    logger.info('üöÄ Iniciando GEI Unified Platform...');
    logger.info('üìã Variables de entorno verificadas');
    logger.info(`üåç NODE_ENV: ${process.env.NODE_ENV}`);
    logger.info(`üîå PORT: ${port}`);
    logger.info(`üìÅ Directorio actual: ${__dirname}`);
    
    // Verificar archivos cr√≠ticos
    logger.info('üîç Verificando archivos cr√≠ticos...');
    const distPath = path.join(__dirname, 'dist');
    const sharedPath = path.join(__dirname, '..', 'shared');
    
    if (fs.existsSync(distPath)) {
      logger.info('‚úÖ Directorio dist existe');
    } else {
      logger.error('‚ùå Directorio dist no existe');
    }
    
    if (fs.existsSync(sharedPath)) {
      logger.info('‚úÖ Directorio shared existe');
    } else {
      logger.error('‚ùå Directorio shared no existe');
    }
    
    // Inicializar base de datos con timeout
    logger.info('üóÑÔ∏è Inicializando base de datos...');
    logger.info('üîÑ ANTES de await initializeDatabase()');
    const dbPromise = initializeDatabase();
    const dbTimeout = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Database initialization timeout')), 30000)
    );
    await Promise.race([dbPromise, dbTimeout]);
    logger.info('üîÑ DESPU√âS de await initializeDatabase()');
    logger.info('‚úÖ Base de datos inicializada');
    
    // Inicializar servicio de notificaciones
    logger.info('üîî Inicializando servicio de notificaciones...');
    logger.info('üîÑ ANTES de new NotificationService()');
    notificationService = new NotificationService(server);
    logger.info('üîÑ DESPU√âS de new NotificationService()');
    logger.info('‚úÖ Servicio de notificaciones inicializado');
    
    // Hacer el servicio disponible globalmente
    (global as any).notificationService = notificationService;
    
    // Inicializar servicios de optimizaci√≥n con timeout
    logger.info('‚ö° Inicializando servicio de cach√©...');
    logger.info('üîÑ ANTES de await cacheService.connect()');
    const cachePromise = cacheService.connect();
    const cacheTimeout = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Cache service timeout')), 15000)
    );
    await Promise.race([cachePromise, cacheTimeout]);
    logger.info('üîÑ DESPU√âS de await cacheService.connect()');
    logger.info('‚úÖ Servicio de cach√© inicializado');
    
    logger.info('üîß Inicializando optimizador de base de datos...');
    logger.info('üîÑ ANTES de await databaseOptimizer.initialize()');
    const optimizerPromise = databaseOptimizer.initialize();
    const optimizerTimeout = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Database optimizer timeout')), 15000)
    );
    await Promise.race([optimizerPromise, optimizerTimeout]);
    logger.info('üîÑ DESPU√âS de await databaseOptimizer.initialize()');
    logger.info('‚úÖ Optimizador de base de datos inicializado');
    
    // Inicializar servicios de IA con timeout
    logger.info('ü§ñ Inicializando servicio de chatbot IA...');
    logger.info('üîÑ ANTES de await aiChatbotService.initialize()');
    const chatbotPromise = aiChatbotService.initialize();
    const chatbotTimeout = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('AI Chatbot timeout')), 15000)
    );
    await Promise.race([chatbotPromise, chatbotTimeout]);
    logger.info('üîÑ DESPU√âS de await aiChatbotService.initialize()');
    logger.info('‚úÖ Servicio de chatbot IA inicializado');
    
    logger.info('üìä Inicializando servicio de an√°lisis predictivo IA...');
    logger.info('üîÑ ANTES de await aiAnalyticsService.initialize()');
    const analyticsPromise = aiAnalyticsService.initialize();
    const analyticsTimeout = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('AI Analytics timeout')), 15000)
    );
    await Promise.race([analyticsPromise, analyticsTimeout]);
    logger.info('üîÑ DESPU√âS de await aiAnalyticsService.initialize()');
    logger.info('‚úÖ Servicio de an√°lisis predictivo IA inicializado');
    
    logger.info('üìÑ Inicializando servicio de generaci√≥n de reportes IA...');
    logger.info('üîÑ ANTES de await aiReportGeneratorService.initialize()');
    const reportPromise = aiReportGeneratorService.initialize();
    const reportTimeout = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('AI Report Generator timeout')), 15000)
    );
    await Promise.race([reportPromise, reportTimeout]);
    logger.info('üîÑ DESPU√âS de await aiReportGeneratorService.initialize()');
    logger.info('‚úÖ Servicio de generaci√≥n de reportes IA inicializado');
    
    // Inicializar servicio de calendario con timeout
    logger.info('üìÖ Inicializando servicio de calendario...');
    logger.info('üîÑ ANTES de await calendarService.initialize()');
    const calendarPromise = calendarService.initialize();
    const calendarTimeout = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Calendar service timeout')), 15000)
    );
    await Promise.race([calendarPromise, calendarTimeout]);
    logger.info('üîÑ DESPU√âS de await calendarService.initialize()');
    logger.info('‚úÖ Servicio de calendario inicializado');
    
    // Hacer los servicios disponibles globalmente
    (global as any).cacheService = cacheService;
    (global as any).databaseOptimizer = databaseOptimizer;
    (global as any).aiChatbotService = aiChatbotService;
    (global as any).aiAnalyticsService = aiAnalyticsService;
    (global as any).aiReportGeneratorService = aiReportGeneratorService;
    (global as any).calendarService = calendarService;
    
    // Iniciar servidor
    logger.info(`üåê Iniciando servidor en puerto ${port}...`);
    logger.info('üîÑ ANTES de server.listen()');
    server.listen(port, () => {
      logger.info('üîÑ DESPU√âS de server.listen() - Callback ejecutado');
      logger.info(`‚úÖ Servidor ejecut√°ndose en puerto ${port}`);
      logger.info(`üìä Health check: http://localhost:${port}/api/health`);
      
      if (process.env.NODE_ENV === 'development') {
        logger.info(`üé® Cliente: http://localhost:3001`);
      }
      
      logger.info('üéâ ¬°Aplicaci√≥n inicializada completamente!');
    });
    logger.info('üîÑ DESPU√âS de server.listen() - Funci√≥n llamada');
    
  } catch (error) {
    logger.error('‚ùå Error al inicializar la aplicaci√≥n:', error);
    logger.error('üìã Stack trace:', error instanceof Error ? error.stack : 'No stack trace available');
    logger.error('üîç Informaci√≥n adicional del error:', {
      name: error instanceof Error ? error.name : 'Unknown',
      message: error instanceof Error ? error.message : String(error),
      timestamp: new Date().toISOString()
    });
    process.exit(1);
  }
}

// Manejo de se√±ales de terminaci√≥n
process.on('SIGTERM', async () => {
  logger.info('üõë Recibida se√±al SIGTERM, cerrando servidor...');
  
  // Cerrar servidor HTTP
  server.close(async () => {
    logger.info('‚úÖ Servidor HTTP cerrado correctamente');
    
    // Cerrar conexiones de base de datos
    try {
      await sql.end();
      logger.info('‚úÖ Conexiones de base de datos cerradas correctamente');
    } catch (error) {
      logger.error('‚ùå Error al cerrar conexiones de base de datos:', error);
    }
    
    process.exit(0);
  });
});

process.on('SIGINT', async () => {
  logger.info('üõë Recibida se√±al SIGINT, cerrando servidor...');
  
  // Cerrar servidor HTTP
  server.close(async () => {
    logger.info('‚úÖ Servidor HTTP cerrado correctamente');
    
    // Cerrar conexiones de base de datos
    try {
      await sql.end();
      logger.info('‚úÖ Conexiones de base de datos cerradas correctamente');
    } catch (error) {
      logger.error('‚ùå Error al cerrar conexiones de base de datos:', error);
    }
    
    process.exit(0);
  });
});

// Inicializar aplicaci√≥n
initializeApp(); 